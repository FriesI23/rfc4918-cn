# 7. 写锁

这个部分描述了与写锁类型相关的特定语义.
写锁是锁类型的一个具体实例, 也是本规范中唯一描述的锁类型.

独占写锁可以保护对应资源: 其防止除锁创建者之外的任何主体进行更改,
以及在其他任何锁令牌未提的情况下 (e.g., 持有锁的客户端进程之外的其他进程).

客户端**必须[MUST]**提交一个锁令牌, 其他人有权在任何修改写锁资源的请求中使用.
写锁涵盖的修改列表包括:

1. 更改写锁资源的以下任意一种情况:

   - 任何变体
   - 任何死属性
   - 任何可被锁定的活属性 (除非另有定义, 否则活属性是可被锁定的).

2. 对于集合内部成员 URI 的任意修改.
   如已添加, 删除或标识为不同资源, 则该集合内部成员 URI 会被认为已修改.
   有关写锁和集合的更多讨论参见[第 7.4 章][SECTION#7.4].

3. 一个修改写锁根的映射, 要么被映射到另一个资源，要么映射到空资源 (e.g., DELETE).

在 HTTP 和 WebDAV 中定义的方法中, PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE,
COPY (用于目标资源), DELETE 和 MKCOL 会受到写锁的影响.
到目前为止, HTTP/WebDAV 中定义的所有其他方法都与写锁无关, 特别是 GET 方法.

接下来的几节将更具体地描述写锁与各种操作的交互方式.

## 7.1. 写锁和属性

尽管那些没有写锁的主体不允许更改资源的属性, 但由于其模式要求, 即使在被锁定的情况下,
活属性的值仍然可能发生变化. 只有死属性和被定义为可锁定的活属性才能保证在写锁期间不发生更改.

## 7.2. 避免丢失更新

尽管写锁有助于防止丢失更新, 但不能保证更新永远不会丢失. 考虑以下情景:

两个客户端 A 和 B 都想编辑资源 "index.html". 客户端 A 是一个 HTTP 客户端,
而不是 WebDAV 客户端, 因此不知道如何执行锁定.

客户端 A 没有锁定文档, 而是执行了 GET 操作, 然后开始编辑.

客户端 B 执行 LOCK 操作，进行了 GET 操作，然后开始编辑.

客户端 B 完成编辑, 执行 PUT 操作，然后执行 UNLOCK 操作.

客户端 A 执行 PUT 操作, 覆盖并导致 B 的所有更改丢失.

以下几个原因导致 WebDAV 协议本身无法防止这种情况发生. 首先, 服务器无法强制所有客户端使用锁,
因为其必须与不理解锁的 HTTP 客户端兼容. 其次, 客户端无法要求服务器支持锁,
因为有非常多中仓库实现, 其中一些依赖于预订 (reservations) 和合并 (mergeing), 而不是锁.
最后, 由于 HTTP 协议是无状态的, 其无法保证 LOCK / GET / PUT / UNLOCK 等操作强制序列执行.

支持锁的 WebDAV 服务器可以通过要求客户端在修改资源之前先锁定资源,
以减少客户端意外覆盖彼此更改的可能性. 这类服务器可以有效阻止 HTTP 1.0 / 1.1 客户端修改资源.

WebDAV 客户端可以通过在与支持锁的 WebDAV 服务器交互时,
使用锁定 (lock) / 检索 (retrieve) / 写入 (write) / 解锁 (unlock) 操作序列 (
至少在默认情况下) 来获得良好的表现。

HTTP 1.1 客户端可以通过在任何会修改资源的请求中使用 If-Match 标头中的实体标签,
已避免覆盖其他客户端的更改.

信息管理者 (Information managers) 可能会尝试通过在客户端实施程序,
要求客户端修改 WebDAV 资源之前先对其进行锁定, 以防止内容被覆盖.
