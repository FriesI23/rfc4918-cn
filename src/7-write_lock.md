# 7. 写锁

这个部分描述了与写锁类型相关的特定语义.
写锁是锁类型的一个具体实例, 也是本规范中唯一描述的锁类型.

独占写锁可以保护对应资源: 其防止除锁创建者之外的任何主体进行更改,
以及在其他任何锁令牌未提的情况下 (e.g., 持有锁的客户端进程之外的其他进程).

客户端**必须[MUST]**提交一个锁令牌, 其他人有权在任何修改写锁资源的请求中使用.
写锁涵盖的修改列表包括:

1. 更改写锁资源的以下任意一种情况:

   - 任何变体
   - 任何死属性
   - 任何可被锁定的活属性 (除非另有定义, 否则活属性是可被锁定的).

2. 对于集合内部成员 URI 的任意修改.
   如已添加, 删除或标识为不同资源, 则该集合内部成员 URI 会被认为已修改.
   有关写锁和集合的更多讨论参见[第 7.4 章][SECTION#7.4].

3. 一个修改写锁根的映射, 要么被映射到另一个资源，要么映射到空资源 (e.g., DELETE).

在 HTTP 和 WebDAV 中定义的方法中, PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE,
COPY (用于目标资源), DELETE 和 MKCOL 会受到写锁的影响.
到目前为止, HTTP/WebDAV 中定义的所有其他方法都与写锁无关, 特别是 GET 方法.

接下来的几节将更具体地描述写锁与各种操作的交互方式.

## 7.1. 写锁和属性

尽管那些没有写锁的主体不允许更改资源的属性, 但由于其模式要求, 即使在被锁定的情况下,
活属性的值仍然可能发生变化. 只有死属性和被定义为可锁定的活属性才能保证在写锁期间不发生更改.

## 7.2. 避免丢失更新

尽管写锁有助于防止丢失更新, 但不能保证更新永远不会丢失. 考虑以下情景:

两个客户端 A 和 B 都想编辑资源 "index.html". 客户端 A 是一个 HTTP 客户端,
而不是 WebDAV 客户端, 因此不知道如何执行锁定.

客户端 A 没有锁定文档, 而是执行了 GET 操作, 然后开始编辑.

客户端 B 执行 LOCK 操作，进行了 GET 操作，然后开始编辑.

客户端 B 完成编辑, 执行 PUT 操作，然后执行 UNLOCK 操作.

客户端 A 执行 PUT 操作, 覆盖并导致 B 的所有更改丢失.

以下几个原因导致 WebDAV 协议本身无法防止这种情况发生. 首先, 服务器无法强制所有客户端使用锁,
因为其必须与不理解锁的 HTTP 客户端兼容. 其次, 客户端无法要求服务器支持锁,
因为有非常多中仓库实现, 其中一些依赖于预订 (reservations) 和合并 (mergeing), 而不是锁.
最后, 由于 HTTP 协议是无状态的, 其无法保证 LOCK / GET / PUT / UNLOCK 等操作强制序列执行.

支持锁的 WebDAV 服务器可以通过要求客户端在修改资源之前先锁定资源,
以减少客户端意外覆盖彼此更改的可能性. 这类服务器可以有效阻止 HTTP 1.0 / 1.1 客户端修改资源.

WebDAV 客户端可以通过在与支持锁的 WebDAV 服务器交互时,
使用锁定 (lock) / 检索 (retrieve) / 写入 (write) / 解锁 (unlock) 操作序列 (
至少在默认情况下) 来获得良好的表现。

HTTP 1.1 客户端可以通过在任何会修改资源的请求中使用 If-Match 标头中的实体标签,
已避免覆盖其他客户端的更改.

信息管理者 (Information managers) 可能会尝试通过在客户端实施程序,
要求客户端修改 WebDAV 资源之前先对其进行锁定, 以防止内容被覆盖.

## 7.3. 写锁与未映射 URL

WebDAV 提供了一种向未映射 URL 发送 LOCK 请求的能力, 以便保留该名称以供使用.
这是一种在创建新资源时避免丢失更新问题的简单方式 (另一种方式是使用 [RFC2616#14.26]
中指定的 If-None-Match 标头). 其另一个好处是立即锁定新资源以供创建者使用.

请注意, 集合不存在丢失更新问题, 因为 MKCOL 只能用于创建集合, 而不能用于覆盖现有集合.
在尝试在创建并锁定集合时, 客户端可以尝试通过将 MKCOL 和 LOCK 请求进行管道化处理,
以增加获得锁的可能性 (但由于服务器不会将两个单独的操作转换为一个原子操作,
所以不能保证这种操作会起作用).

对未映射 URL 的锁定成功请求**必会[MUST]**导致创建一个带有空内容的已锁定 (非集合) 资源.
随后, 成功的 (有正确的锁定令牌的) PUT 请求会提供资源内容.
需要注意的是, LOCK 请求没有允许客户端提供 `Content-Type` 或 `Content-Language` 的机制,
因此服务器将使用默认值或空值，并依赖于随后的 PUT 请求来获得正确的值.

使用 LOCK 创建的资源除了是空的外, 每个方面都与普通资源表现相同.
它与使用空正文的 PUT 请求创建资源 (这种情况下未指定 `Content-Type` 和
`Content-Language`), 后在同一资源上使用 LOCK 请求这种行为相同.
根据此模型, 一个已被锁定的空资源:

- 可以被读取, 删除, 移动和复制, 并且在所有方面都表现都与普通非集合资源一致.

- 显示为其父集合的成员.

- **不应[SHOULD_NOT]**在其锁定解除后消失 (因此客户端必须如同在任何其他操作或非空资源上一样,
  要负责清理自己的烂摊子).

- **可能不会[MAY_NOT]**有尚未由客户端指定的属性值, 如 `DAV:getcontentlanguage` 等.

- 可以通过 PUT 请求更新 (添加内容).

- **不得[MUST_NOT]**转换为集合. 服务器**必须[MUST]**拒绝 MKCOL 请求
  (就像拒绝对任何现有非集合资源的 MKCOL 请求一样).

- **必须[MUST]**为 `DAV:lockdiscovery` 和 `DAV:supportedlock` 属性定义值.

- 响应必须使用 "201 Created" 响应码指示已创建资源 (对现有资源的 LOCK 请求将导致返回
  "200 OK"). 响应正文就像对现有资源的 LOCK 请求一样, 必须包含 `DAV:lockdiscovery` 属性.

客户端会在锁定空资源后不久使用 PUT 和可能的 PROPPATCH 更新该资源, 这种行为是可预料的.

作为替代方案, 且为了与 [RFC2518] 的向后兼容性,
服务器可以选择实现 Lock-Null Resources (LNRs) (参见[附录 D][APPENDIX#D] 中的定义).
客户端可以非常容易的支持与 LNR 旧模型 和推荐的 "锁定空资源" 模型的服务器进行互操作,
只需在 LOCK 后尝试对未映射 URL (而不是 MKCOL 或 GET) 进行 PUT,
同时不依赖于 LNR 中的特定属性.

## 7.4. 写锁与集合

有两种类型的集合写锁. 一个集合上 `depth-0` 的写锁保护该集合的属性以及该集合的内部成员 URL,
但不保护成员资源的内容或属性 (如果集合本身有任意正文, 则也会受到保护).
一个集合上 `depth-infinity` 的写锁不仅提供与该集合相同的保护,
还为对每个成员资源提供写锁保护.

换句话说, 无论哪种类型的写锁都会保护: 将在写锁定的集合中创建新资源的所有请求,
将要删除写锁定的集合内部成员 URL 的所有请求, 以及将要更改任意内部成员段名称的所有请求.

因此, 集合写锁可以保护以下所有操作:

- **删除 (DELETE)** 集合的直接内部成员
- 将内部成员**移出 (MOVE out)** 集合
- 将内部成员**移入 (MOVE into)** 集合
- 使用 **移动 (MOVE)** 操作在集合内重命名内部成员
- 将内部成员**复制 (COPY)** 到集合
- 发起 PUT 或 MKCOL 请求以创建新的内部成员

在需要单独锁定内部成员的情况下, 除了内部成员本身的锁令牌外, 还需要该集合的锁令牌.

此外, `depth-infinity` 锁定将影响对已锁定集合的所有成员执行的所有写操作.
使用 `depth-infinity` 锁定时, 锁根标识的资源会被直接锁定, 其所有成员会被间接锁定.

- 任何被 `depth-infinity` 锁定集合的后代, 新添加的资源会变成间接锁定状态.

- 任何间接锁定的资源如果被移出已锁定的集合并放入未锁定的集合, 将变成未锁定状态.

- 任何间接锁定的资源如果被移出已锁定的源集合并放入 `depth-infinity` 锁定的目标集合,
  将会保持间接锁定状态, 但此时由目标集合锁保护 (之后如果进行进一步更改需要目标集合的锁令牌).

如果向集合发出无限深度写入 LOCK 请求时, 该集合包含标识当前以与新锁冲突的方式锁资源的成员 URL
(参见[第 6.1 章][SECTION#6.1]中第三点), 请求**必须[MUST]**以 423 (Locked) 状态码失败,
且响应**应该[SHOULD]**包含 "no-conflicting-lock" 前置条件.

如果锁定请求导致将资源的 URL 成为 `depth-infinity` 锁定集合的内部成员 URL,
则新资源必须自动由该锁保护. 例如, 如果集合 `/a/b/` 写锁定, 且资源 `/c` 被移动到 `/a/b/c`,
则资源 `/a/b/c` 将被添加到写锁定中.

## 7.5. 写锁与 IF 请求标头

用户代理在对已锁定资源请求操作时, 必须证明其对锁了解. 否则可能会出现以下情况.
考虑如下场景, 用户 A 运行的程序 A 在某个资源上获取了写锁定. 另外一个同样由用户 A 运行的程序 B,
不知道程序 A 获取锁, 然而对已锁资源执行了 PUT 请求. 在这种情况下, PUT 请求成功,
因为锁与主体 (principa) 而不是程序相关联. 因此, 程序 B 因为使用了主体 A 的凭证,
所以被允许执行 PUT 请求. 然而, 如果程序 B 了解该锁定的情况, 其就不会覆盖资源,
而会更偏于向用户呈现一个描述冲突的对话框.
对于这种情况, 需要一种机制来防止不同程序意外忽略具有相同授权的其他程序所获取的锁.

为了防止这些冲突, 授权的主体**必须[MUST]**为所有已锁定的资源提交一个锁令牌,
以提供给可能更改的资源的方法, 否则该方法**必须[MUST]**失败.
锁令牌随 If 标头被提交. 例如, 如果要移动资源并且源和目标都已被锁定,
则**必须[MUST]**在 If 标头中提交两个锁令牌, 一个用于源, 另一个用于目标.

### 7.5.1. 示例 - 写锁与 COPY

```http
>>Request
COPY /~fielding/index.html HTTP/1.1
Host: www.example.com
Destination: http://www.example.com/users/f/fielding/index.html
If: <http://www.example.com/users/f/fielding/index.html>
    (<urn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6>)

>>Response
HTTP/1.1 204 No Content
```

在该示例中, 尽管源和目标都已被锁定, 但只需要提交一个锁令牌 (用于目标上的那个锁).
这是因为源资源不会被 COPY 修改, 因此也不受写锁的影响.
在该示例中, 用户代理身份验证已经先通过 HTTP 协议范围之外的机制在底层传输层中进行.

### 7.5.2. 示例 - 删除锁集合的成员

考虑一个带有 `depth-infinity` 的互斥写锁集合 "/locked",
并尝试删除其内部成员 "/locked/member":

```http
>>Request
DELETE /locked/member HTTP/1.1
Host: example.com

>>Response
HTTP/1.1 423 Locked
Content-Type: application/xml; charset="utf-8"
Content-Length: xxxx

<?xml version="1.0" encoding="utf-8" ?>
<D:error xmlns:D="DAV:">
  <D:lock-token-submitted>
    <D:href>/locked/</D:href>
  </D:lock-token-submitted>
</D:error>
```

因此, 客户端需要在请求中提交锁令牌其成功.
为此, 可以使用各种形式的 If 标头 (参见[第 10.4 章][SECTION#10.4]).

```http
"No-Tag-List" format:
  If: (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)

"Tagged-List" format, for "http://example.com/locked/":
  If: <http://example.com/locked/>
      (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)

"Tagged-List" format, for "http://example.com/locked/member":
  If: <http://example.com/locked/member>
      (<urn:uuid:150852e2-3847-42d5-8cbe-0f4f296f26cf>)
```

需要注意的是, 为了提交锁令牌, 实际的形式并不重要;
重要的是锁令牌出现在 If 标头中, 并且该 If 标头本身评估为真 (true).

## 7.6. 写锁与 COPY/MOVE

对于 COPY 方法的调用, **不得[MUST_NOT]**复制源上任何活动的写锁. 但是, 如前所述,
如果 COPY 将资源复制到一个使用 `depth-infinity` 锁定的集合中, 则资源将被添加到该锁中.

对于写锁的资源, 一个成功的 MOVE 请求**不得[MUST_NOT]**将写锁与资源一起移动.
但是, 如果目标处存在锁, 则服务器**必须[MUST]**将移动的资源添加到目标锁范围内. 例如,
如果 MOVE 操作使资源成为具有 `depth-infinity` 锁定的集合的子级, 则资源将被添加到该集合锁中.
此外, 如果具有 `depth-infinity` 锁定的资源被移动到同一锁范围内的目标
(例如, 在锁涵盖的 URL 命名空间树内), 则被移动的资源将被再次添加到锁定中.
这两个示例, 正如[第 7.5 章][SECTION#7.5]中所规定的,
必须提交一个包含源和目标的锁令牌的 If 标头.

## 7.7. 刷新写锁

客户端**不得[MUST_NOT]**重复提交相同的写锁请求. 需要注意的是,
客户端始终知道其正在重新提交相同的锁请求, 因为为了对已锁定的资源进行请求，
其必须在 If 标头中包含锁令牌.

但是, 客户端可能提交一个带有 If 标头但没有正文的 LOCK 请求.
接收到没有正文 LOCK 请求的服务器**不得[MUST_NOT]**创建新的锁
-- 这种形式的 LOCK 请求仅用于 "刷新" 现有锁 (至少意味着必须重置与锁关联的任何定时器).

客户端可能通过其锁刷新请求来提交包含任意值的 Timeout 标头.
服务器始终可以忽略客户端提交的 Timeout 标头,
并且服务器**可能[MAY]**使用与之前用于锁超时不同的时间来刷新锁,
前提是服务器在 LOCK 刷新响应中通告新的值.

如果在刷新 LOCK 请求的响应中收到错误, 则客户端**不得[MUST_NOT]**假设锁已被刷新.
