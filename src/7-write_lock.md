# 7. 写锁

这个部分描述了与写锁类型相关的特定语义.
写锁是锁类型的一个具体实例, 也是本规范中唯一描述的锁类型.

独占写锁可以保护对应资源: 其防止除锁创建者之外的任何主体进行更改,
以及在其他任何锁令牌未提的情况下 (e.g., 持有锁的客户端进程之外的其他进程).

客户端**必须[MUST]**提交一个锁令牌, 其他人有权在任何修改写锁资源的请求中使用.
写锁涵盖的修改列表包括:

1. 更改写锁资源的以下任意一种情况:

   - 任何变体
   - 任何死属性
   - 任何可被锁定的活属性 (除非另有定义, 否则活属性是可被锁定的).

2. 对于集合内部成员 URI 的任意修改.
   如已添加, 删除或标识为不同资源, 则该集合内部成员 URI 会被认为已修改.
   有关写锁和集合的更多讨论参见[第 7.4 章][SECTION#7.4].

3. 一个修改写锁根的映射, 要么被映射到另一个资源，要么映射到空资源 (e.g., DELETE).

在 HTTP 和 WebDAV 中定义的方法中, PUT, POST, PROPPATCH, LOCK, UNLOCK, MOVE,
COPY (用于目标资源), DELETE 和 MKCOL 会受到写锁的影响.
到目前为止, HTTP/WebDAV 中定义的所有其他方法都与写锁无关, 特别是 GET 方法.

接下来的几节将更具体地描述写锁与各种操作的交互方式.

## 7.1. 写锁和属性

尽管那些没有写锁的主体不允许更改资源的属性, 但由于其模式要求, 即使在被锁定的情况下,
活属性的值仍然可能发生变化. 只有死属性和被定义为可锁定的活属性才能保证在写锁期间不发生更改.

## 7.2. 避免丢失更新

尽管写锁有助于防止丢失更新, 但不能保证更新永远不会丢失. 考虑以下情景:

两个客户端 A 和 B 都想编辑资源 "index.html". 客户端 A 是一个 HTTP 客户端,
而不是 WebDAV 客户端, 因此不知道如何执行锁定.

客户端 A 没有锁定文档, 而是执行了 GET 操作, 然后开始编辑.

客户端 B 执行 LOCK 操作，进行了 GET 操作，然后开始编辑.

客户端 B 完成编辑, 执行 PUT 操作，然后执行 UNLOCK 操作.

客户端 A 执行 PUT 操作, 覆盖并导致 B 的所有更改丢失.

以下几个原因导致 WebDAV 协议本身无法防止这种情况发生. 首先, 服务器无法强制所有客户端使用锁,
因为其必须与不理解锁的 HTTP 客户端兼容. 其次, 客户端无法要求服务器支持锁,
因为有非常多中仓库实现, 其中一些依赖于预订 (reservations) 和合并 (mergeing), 而不是锁.
最后, 由于 HTTP 协议是无状态的, 其无法保证 LOCK / GET / PUT / UNLOCK 等操作强制序列执行.

支持锁的 WebDAV 服务器可以通过要求客户端在修改资源之前先锁定资源,
以减少客户端意外覆盖彼此更改的可能性. 这类服务器可以有效阻止 HTTP 1.0 / 1.1 客户端修改资源.

WebDAV 客户端可以通过在与支持锁的 WebDAV 服务器交互时,
使用锁定 (lock) / 检索 (retrieve) / 写入 (write) / 解锁 (unlock) 操作序列 (
至少在默认情况下) 来获得良好的表现。

HTTP 1.1 客户端可以通过在任何会修改资源的请求中使用 If-Match 标头中的实体标签,
已避免覆盖其他客户端的更改.

信息管理者 (Information managers) 可能会尝试通过在客户端实施程序,
要求客户端修改 WebDAV 资源之前先对其进行锁定, 以防止内容被覆盖.

## 7.3. 写锁与未映射 URL

WebDAV 提供了一种向未映射 URL 发送 LOCK 请求的能力, 以便保留该名称以供使用.
这是一种在创建新资源时避免丢失更新问题的简单方式 (另一种方式是使用 [RFC2616#14.26]
中指定的 If-None-Match 标头). 其另一个好处是立即锁定新资源以供创建者使用.

请注意, 集合不存在丢失更新问题, 因为 MKCOL 只能用于创建集合, 而不能用于覆盖现有集合.
在尝试在创建并锁定集合时, 客户端可以尝试通过将 MKCOL 和 LOCK 请求进行管道化处理,
以增加获得锁的可能性 (但由于服务器不会将两个单独的操作转换为一个原子操作,
所以不能保证这种操作会起作用).

对未映射 URL 的锁定成功请求**必会[MUST]**导致创建一个带有空内容的已锁定 (非集合) 资源.
随后, 成功的 (有正确的锁定令牌的) PUT 请求会提供资源内容.
需要注意的是, LOCK 请求没有允许客户端提供 `Content-Type` 或 `Content-Language` 的机制,
因此服务器将使用默认值或空值，并依赖于随后的 PUT 请求来获得正确的值.

使用 LOCK 创建的资源除了是空的外, 每个方面都与普通资源表现相同.
它与使用空正文的 PUT 请求创建资源 (这种情况下未指定 `Content-Type` 和
`Content-Language`), 后在同一资源上使用 LOCK 请求这种行为相同.
根据此模型, 一个已被锁定的空资源:

- 可以被读取, 删除, 移动和复制, 并且在所有方面都表现都与普通非集合资源一致.

- 显示为其父集合的成员.

- **不应[SHOULD_NOT]**在其锁定解除后消失 (因此客户端必须如同在任何其他操作或非空资源上一样,
  要负责清理自己的烂摊子).

- **可能不会[MAY_NOT]**有尚未由客户端指定的属性值, 如 `DAV:getcontentlanguage` 等.

- 可以通过 PUT 请求更新 (添加内容).

- **不得[MUST_NOT]**转换为集合. 服务器**必须[MUST]**拒绝 MKCOL 请求
  (就像拒绝对任何现有非集合资源的 MKCOL 请求一样).

- **必须[MUST]**为 `DAV:lockdiscovery` 和 `DAV:supportedlock` 属性定义值.

- 响应必须使用 "201 Created" 响应码指示已创建资源 (对现有资源的 LOCK 请求将导致返回
  "200 OK"). 响应正文就像对现有资源的 LOCK 请求一样, 必须包含 `DAV:lockdiscovery` 属性.

客户端会在锁定空资源后不久使用 PUT 和可能的 PROPPATCH 更新该资源, 这种行为是可预料的.

作为替代方案, 且为了与 [RFC2518] 的向后兼容性,
服务器可以选择实现 Lock-Null Resources (LNRs) (参见[附录 D][APPENDIX#D] 中的定义).
客户端可以非常容易的支持与 LNR 旧模型 和推荐的 "锁定空资源" 模型的服务器进行互操作,
只需在 LOCK 后尝试对未映射 URL (而不是 MKCOL 或 GET) 进行 PUT,
同时不依赖于 LNR 中的特定属性.

## 7.4. 写锁与集合

有两种类型的集合写锁. 一个集合上 `depth-0` 的写锁保护该集合的属性以及该集合的内部成员 URL,
但不保护成员资源的内容或属性 (如果集合本身有任意正文, 则也会受到保护).
一个集合上 `depth-infinity` 的写锁不仅提供与该集合相同的保护,
还为对每个成员资源提供写锁保护.

换句话说, 无论哪种类型的写锁都会保护: 将在写锁定的集合中创建新资源的所有请求,
将要删除写锁定的集合内部成员 URL 的所有请求, 以及将要更改任意内部成员段名称的所有请求.

因此, 集合写锁可以保护以下所有操作:

- **删除 (DELETE)** 集合的直接内部成员
- 将内部成员**移出 (MOVE out)** 集合
- 将内部成员**移入 (MOVE into)** 集合
- 使用 **移动 (MOVE)** 操作在集合内重命名内部成员
- 将内部成员**复制 (COPY)** 到集合
- 发起 PUT 或 MKCOL 请求以创建新的内部成员

在需要单独锁定内部成员的情况下, 除了内部成员本身的锁令牌外, 还需要该集合的锁令牌.

此外, `depth-infinity` 锁定将影响对已锁定集合的所有成员执行的所有写操作.
使用 `depth-infinity` 锁定时, 锁根标识的资源会被直接锁定, 其所有成员会被间接锁定.

- 任何被 `depth-infinity` 锁定集合的后代, 新添加的资源会变成间接锁定状态.

- 任何间接锁定的资源如果被移出已锁定的集合并放入未锁定的集合, 将变成未锁定状态.

- 任何间接锁定的资源如果被移出已锁定的源集合并放入 `depth-infinity` 锁定的目标集合,
  将会保持间接锁定状态, 但此时由目标集合锁保护 (之后如果进行进一步更改需要目标集合的锁令牌).

如果向集合发出无限深度写入 LOCK 请求时, 该集合包含标识当前以与新锁冲突的方式锁资源的成员 URL
(参见[第 6.1 章][SECTION#6.1]中第三点), 请求**必须[MUST]**以 423 (Locked) 状态码失败,
且响应**应该[SHOULD]**包含 "no-conflicting-lock" 前置条件.

如果锁定请求导致将资源的 URL 成为 `depth-infinity` 锁定集合的内部成员 URL,
则新资源必须自动由该锁保护. 例如, 如果集合 `/a/b/` 写锁定, 且资源 `/c` 被移动到 `/a/b/c`,
则资源 `/a/b/c` 将被添加到写锁定中.
