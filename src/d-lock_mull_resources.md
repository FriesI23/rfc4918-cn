# 附录 D. 锁空 (Lock-null) 资源

原始的 WebDAV 锁定模型在创建未映射的 URL 时会生成 "锁空资源 (LNRs)".
该模型过于复杂, 并在一些互操作性和实现中被发现存在问题. 新的 WebDAV 模型在锁定未映射的 URL
(参阅[第 7.3 章][SECTION#7.3]) 创建了 "空锁定资源 (locked empty resources)".
而锁空资源被弃用. 这个部分简要讨论了原始模型, 因为客户端**必须[MUST]**能够处理其中的任一模型.

在原始的 LNRs 模型中, 不再建议实施:

- 锁定占用资源有时显示为 "Not Found". 服务器对除 PUT, MKCOL, OPTIONS, PROPFIND,
  LOCK, UNLOCK 之外的任何方法都会响应 404 或 405.
- 然而, LNRs 会显示为其父集合的成员.
- 如果锁在将其转换为常规资源之前消失, 服务器将完全删除该 LNRs (URI 将变为未映射).
  需要记住, 锁不仅会在到期或解锁时, 还会在资源重命名或移动时消失,
  或任何父集合重命名或移动时被删除也会消失.
- 如果对 URL 的 PUT 请求成功, 服务器会将 LNRs 转换为常规资源.
- 如果对 URL 的 MKCOL 请求成功 (尽管互操作性经验表明, 并不是所有服务器都遵循此要求),
  服务器会将 LNRs 转换为集合.
- LNRs 已为 `DAV:lockdiscovery` 和 `DAV:supportedlock` 属性定义了属性值,
  但不一定也对如 `DAV:getcontenttype` 等其他属性定义属性值.

客户端可以通过在未映射的 URL 上仅尝试在 LOCK 之后执行 PUT,
来容易地与支持 LNRs 旧模型和建议的 "空锁定资源" 模型的服务器进行互操作.

## D.1. 客户端使用 LOCK 创建资源指南

根据该规范实现的 WebDAV 客户端可能会遇到早期使用[RFC2518]实现的创建 LNRs 以及创建 "空锁定资源" 的服务器.
LOCK 请求响应不会指示创建了哪种类型的资源. 有一些技巧可以帮助客户端处理其中任一类型.

- 如果客户端希望避免意外创建 "LNRs" 或者 "空锁定资源",
  可以在 LOCK 请求中包括一个 `If-Match: *` 标头, 以防止服务器创建新资源.

- 如果 LOCK 请求创建了一个资源, 且客户端随后想要使用 COPY 或 MOVE 请求覆盖该资源,
  客户端应该包括一个 `"Overwrite: T"` 标头.

- 如果 LOCK 请求创建了一个资源, 然后客户端决定删除该资源, 对于 LNRs,
  DELETE 请求应该失败, 而应该使用 UNLOCK 解锁该资源. 但对于 "空锁定资源",
  UNLOCK 不会使资源消失. 因此, 客户端可能需要尝试两种请求, 并忽略其中一个请求中的错误.

> 译者注: 两者 DELETE/UNLOCK 时具体有什么区别:
>
> - 对于 "锁空资源 (LNRs)"
>   - 锁定占位资源是在对不存在的资源发出 LOCK 请求时创建的占位符资源, 其没有任何内容。
>   - 当尝试删除该资源时, 通常会失败并响应 404 Not Found, 因为该资源本身实际上并不存在.
>   - 应该对与其关联的锁令牌使用 UNLOCK 方法., 这将解锁资源并删除锁定占位资源.
> - 对于 "空锁定资源"
>   - 空锁定资源是存在但没有内容的资源.
>   - 当尝试删除空锁定资源时, DELETE 请求通常会成功, 因为该资源存在.
>   - 要释放空锁定资源, 可以使用 UNLOCK 方法. 但使用 UNLOCK 不会删除资源本身, 而只是解锁.

<!-- refs -->

[SECTION#7.3]: 7-write_lock.md#73-写锁与未映射-url
